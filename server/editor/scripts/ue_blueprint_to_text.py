from typing import Any, Dict, List, Optional
import json
import os
import re
import tempfile
import unreal


BEGIN_OBJECT_RE = re.compile(
    r'^Begin Object(?: Class=(?P<class>[^\s]+))? Name="(?P<name>[^"]+)"(?: Archetype=[^\s]+)? ExportPath="(?P<export_path>[^"]+)"$'
)
END_OBJECT_RE = re.compile(r"^End Object$")
PIN_RE = re.compile(r"^CustomProperties Pin \((?P<body>.*)\)$")
NEW_VARIABLE_RE = re.compile(r"^NewVariables\(\d+\)=\((?P<body>.*)\)$")


def _safe_int(value: Optional[str]) -> Optional[int]:
    if value is None:
        return None
    try:
        return int(value)
    except Exception:
        return None


def _extract_field(blob: str, key: str) -> Optional[str]:
    quoted = re.search(rf'{re.escape(key)}="([^"]*)"', blob)
    if quoted:
        return quoted.group(1)
    plain = re.search(rf"{re.escape(key)}=([^,\)]+)", blob)
    if plain:
        return plain.group(1)
    return None


def _extract_parenthesized_field(blob: str, key: str) -> Optional[str]:
    marker = f"{key}=("
    start = blob.find(marker)
    if start == -1:
        return None

    index = start + len(marker)
    depth = 1
    in_quote = False
    out: List[str] = []

    while index < len(blob):
        ch = blob[index]
        prev = blob[index - 1] if index > 0 else ""
        if ch == '"' and prev != "\\":
            in_quote = not in_quote

        if not in_quote:
            if ch == "(":
                depth += 1
            elif ch == ")":
                depth -= 1
                if depth == 0:
                    return "".join(out)

        out.append(ch)
        index += 1

    return None


def _class_from_export_path(export_path: str, explicit_class: Optional[str]) -> str:
    if explicit_class:
        return explicit_class.split(".")[-1]

    match = re.search(r"/Script/[^']+\.([A-Za-z0-9_]+)'", export_path)
    if match:
        return match.group(1)

    return "Unknown"


def _short_symbol(value: str) -> str:
    text = value.strip().strip('"')
    if "'" in text:
        parts = [part for part in text.split("'") if part]
        if parts:
            text = parts[-1]
    if "/" in text:
        text = text.split("/")[-1]
    if "." in text:
        text = text.split(".")[-1]
    return text


def _infer_graph_type(graph_name: str) -> str:
    lower = graph_name.lower()
    if "eventgraph" in lower:
        return "EventGraph"
    if "construction" in lower:
        return "ConstructionScript"
    if "macro" in lower:
        return "Macro"
    return "Function"


def _parse_reference(line: str, key: str) -> Optional[Dict[str, str]]:
    body_match = re.search(rf"{re.escape(key)}=\((.*)\)$", line)
    if not body_match:
        return None

    body = body_match.group(1)
    member_name = _extract_field(body, "MemberName")
    member_parent = _extract_field(body, "MemberParent")
    member_guid = _extract_field(body, "MemberGuid")

    reference: Dict[str, str] = {}
    if member_name:
        reference["member_name"] = member_name
    if member_parent:
        reference["member_parent"] = member_parent
        reference["member_parent_short"] = _short_symbol(member_parent)
    if member_guid:
        reference["member_guid"] = member_guid

    return reference if reference else None


def _parse_pin(body: str) -> Dict[str, Any]:
    pin: Dict[str, Any] = {}

    pin_id = _extract_field(body, "PinId")
    pin_name = _extract_field(body, "PinName")
    direction_raw = _extract_field(body, "Direction")
    pin_category = _extract_field(body, "PinType.PinCategory")
    pin_sub_object = _extract_field(body, "PinType.PinSubCategoryObject")

    if pin_id:
        pin["id"] = pin_id
    if pin_name is not None:
        pin["name"] = pin_name
    if direction_raw:
        upper = direction_raw.upper()
        if "OUTPUT" in upper:
            pin["direction"] = "Output"
        elif "INPUT" in upper:
            pin["direction"] = "Input"
        else:
            pin["direction"] = direction_raw
    if pin_category:
        pin["type"] = pin_category
    if pin_sub_object and pin_sub_object != "None":
        pin["sub_type"] = pin_sub_object

    default_value = _extract_field(body, "DefaultValue")
    if default_value is None:
        default_value = _extract_field(body, "AutogeneratedDefaultValue")
    if default_value:
        pin["default"] = default_value

    default_text = None
    if "DefaultTextValue=" in body:
        default_text_match = re.search(r"DefaultTextValue=(.*?),PersistentGuid=", body)
        if default_text_match:
            default_text = default_text_match.group(1)
    if default_text:
        pin["default_text"] = default_text

    linked_to_blob = _extract_parenthesized_field(body, "LinkedTo")
    if linked_to_blob:
        linked_nodes = []
        for match in re.finditer(r"([A-Za-z_][A-Za-z0-9_]*)\s+([A-F0-9]{16,32})", linked_to_blob):
            linked_nodes.append(
                {
                    "node": match.group(1),
                    "pin_id": match.group(2),
                }
            )
        if linked_nodes:
            pin["linked_to"] = linked_nodes

    return pin


def _parse_new_variable(body: str) -> Optional[Dict[str, Any]]:
    name = _extract_field(body, "VarName")
    if not name:
        return None

    variable: Dict[str, Any] = {
        "name": name,
    }

    friendly_name = _extract_field(body, "FriendlyName")
    if friendly_name:
        variable["friendly_name"] = friendly_name

    property_flags = _extract_field(body, "PropertyFlags")
    if property_flags:
        variable["property_flags"] = property_flags

    pin_category = _extract_field(body, "PinCategory")
    if pin_category:
        variable["type"] = pin_category

    pin_sub_object = _extract_field(body, "PinSubCategoryObject")
    if pin_sub_object and pin_sub_object != "None":
        variable["sub_type"] = pin_sub_object

    container_type = _extract_field(body, "ContainerType")
    if container_type and container_type != "None":
        variable["container"] = container_type

    return variable


def _export_asset_text(asset) -> str:
    export_task = unreal.AssetExportTask()
    export_task.automated = True
    export_task.prompt = False
    export_task.replace_identical = True
    export_task.exporter = None
    export_task.object = asset

    temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=".uasset.copy")
    export_file_path = temp_file.name
    temp_file.close()

    try:
        export_task.filename = export_file_path
        result = unreal.Exporter.run_asset_export_task(export_task)
        if not result:
            raise RuntimeError(
                f"Failed to export asset {asset.get_name()} to {export_file_path}"
            )

        with open(export_file_path, "rb") as file:
            data = file.read()
        return data.decode("utf-8", errors="ignore")
    finally:
        if os.path.exists(export_file_path):
            os.unlink(export_file_path)


def blueprint_to_text(asset_path: str) -> Dict[str, Any]:
    asset = unreal.EditorAssetLibrary.load_asset(asset_path)
    if not asset:
        return {"error": f"Asset not found: {asset_path}"}

    asset_class_name = asset.get_class().get_name()
    if "Blueprint" not in asset_class_name:
        return {
            "error": f"Asset is not a Blueprint-like asset: {asset_path} (class: {asset_class_name})"
        }

    export_text = _export_asset_text(asset)
    if not export_text.strip():
        return {"error": f"Exported text is empty for asset: {asset_path}"}

    result: Dict[str, Any] = {
        "name": asset.get_name(),
        "path": asset.get_path_name(),
        "asset_class": asset_class_name,
        "source": "AssetExportTask text export parsing",
    }

    # Runtime metadata where available.
    try:
        if hasattr(asset, "generated_class"):
            generated_class = asset.generated_class()
            if generated_class:
                result["generated_class"] = generated_class.get_name()
                parent_class = generated_class.get_super_class()
                if parent_class:
                    result["parent_class"] = parent_class.get_name()
    except Exception:
        pass

    graphs_by_name: Dict[str, Dict[str, Any]] = {}
    variables: List[Dict[str, Any]] = []
    stack: List[Dict[str, Any]] = []

    for raw_line in export_text.splitlines():
        stripped = raw_line.strip()
        if not stripped:
            continue

        begin_match = BEGIN_OBJECT_RE.match(stripped)
        if begin_match:
            explicit_class = begin_match.group("class")
            object_name = begin_match.group("name")
            export_path = begin_match.group("export_path")
            class_name = _class_from_export_path(export_path, explicit_class)

            context: Dict[str, Any] = {
                "name": object_name,
                "class_name": class_name,
                "export_path": export_path,
                "kind": "other",
            }

            if class_name == "EdGraph":
                graph = graphs_by_name.get(object_name)
                if not graph:
                    graph = {
                        "name": object_name,
                        "graph_type": _infer_graph_type(object_name),
                        "nodes": [],
                        "_node_map": {},
                    }
                    graphs_by_name[object_name] = graph
                context["kind"] = "graph"
                context["graph_name"] = object_name

            elif "K2Node_" in class_name:
                parent_graph_name = None
                for parent in reversed(stack):
                    if parent.get("kind") == "graph":
                        parent_graph_name = parent.get("graph_name")
                        break

                if not parent_graph_name:
                    parent_graph_name = "UnknownGraph"
                    if parent_graph_name not in graphs_by_name:
                        graphs_by_name[parent_graph_name] = {
                            "name": parent_graph_name,
                            "graph_type": "Unknown",
                            "nodes": [],
                            "_node_map": {},
                        }

                graph = graphs_by_name[parent_graph_name]
                node_map = graph["_node_map"]
                node = node_map.get(object_name)
                if not node:
                    node = {
                        "name": object_name,
                        "class": class_name,
                        "pins": [],
                    }
                    node_map[object_name] = node
                    graph["nodes"].append(node)
                else:
                    node["class"] = class_name

                context["kind"] = "node"
                context["node"] = node
                context["graph_name"] = parent_graph_name

            stack.append(context)
            continue

        if END_OBJECT_RE.match(stripped):
            if stack:
                stack.pop()
            continue

        if not stack:
            continue

        current = stack[-1]

        variable_match = NEW_VARIABLE_RE.match(stripped)
        if variable_match:
            variable = _parse_new_variable(variable_match.group("body"))
            if variable:
                variables.append(variable)
            continue

        if current.get("kind") != "node":
            continue

        node = current["node"]

        node_pos_x = re.search(r"^NodePosX=(-?\d+)$", stripped)
        if node_pos_x:
            node["pos_x"] = _safe_int(node_pos_x.group(1))
            continue

        node_pos_y = re.search(r"^NodePosY=(-?\d+)$", stripped)
        if node_pos_y:
            node["pos_y"] = _safe_int(node_pos_y.group(1))
            continue

        node_guid = re.search(r"^NodeGuid=([A-F0-9]{32})$", stripped)
        if node_guid:
            node["guid"] = node_guid.group(1)
            continue

        if stripped.startswith("NodeComment="):
            node["comment"] = stripped[len("NodeComment=") :].strip().strip('"')
            continue

        if stripped.startswith("EventReference="):
            event_ref = _parse_reference(stripped, "EventReference")
            if event_ref:
                node["event_reference"] = event_ref
                if "member_name" in event_ref:
                    node["event_name"] = event_ref["member_name"]
            continue

        if stripped.startswith("FunctionReference="):
            function_ref = _parse_reference(stripped, "FunctionReference")
            if function_ref:
                node["function_reference"] = function_ref
                if "member_name" in function_ref:
                    node["function"] = function_ref["member_name"]
                if "member_parent_short" in function_ref:
                    node["function_owner"] = function_ref["member_parent_short"]
            continue

        if stripped.startswith("VariableReference="):
            variable_ref = _parse_reference(stripped, "VariableReference")
            if variable_ref:
                node["variable_reference"] = variable_ref
                if "member_name" in variable_ref:
                    node["variable"] = variable_ref["member_name"]
            continue

        if stripped.startswith("CustomFunctionName="):
            custom_name = stripped[len("CustomFunctionName=") :].strip().strip('"')
            if custom_name:
                node["custom_function"] = custom_name
            continue

        pin_match = PIN_RE.match(stripped)
        if pin_match:
            pin = _parse_pin(pin_match.group("body"))
            pin_id = pin.get("id")
            existing = node.get("pins", [])
            if pin_id:
                duplicate = any(existing_pin.get("id") == pin_id for existing_pin in existing)
                if not duplicate:
                    existing.append(pin)
            else:
                existing.append(pin)
            continue

    graphs: List[Dict[str, Any]] = []
    for graph in graphs_by_name.values():
        graph.pop("_node_map", None)
        graph["node_count"] = len(graph["nodes"])
        graphs.append(graph)

    if variables:
        result["variables"] = variables
    if graphs:
        result["graphs"] = graphs
        result["graph_count"] = len(graphs)
        result["node_count"] = sum(graph.get("node_count", 0) for graph in graphs)

    result["line_count"] = len(export_text.splitlines())
    result["character_count"] = len(export_text)

    return result


def main():
    result = blueprint_to_text("${asset_path}")
    print(json.dumps(result, indent=2))


if __name__ == "__main__":
    main()
